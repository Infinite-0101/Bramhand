<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; }
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
            opacity: 0.8;
        }
        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror the video */
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
        }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 5px 0; font-size: 0.9rem; color: #ccc; }
        .highlight { color: #00ffcc; font-weight: bold; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui">
        <h1>Particle Core</h1>
        <p>üñê <b>1 Finger:</b> Heart Template</p>
        <p>‚úåÔ∏è <b>2 Fingers:</b> Flower Template</p>
        <p>ü§ü <b>3 Fingers:</b> Saturn Template</p>
        <p>üññ <b>4 Fingers:</b> DNA Helix</p>
        <p>‚úã <b>Open Hand:</b> Firework Sphere</p>
        <br>
        <p>ü§è <b>Pinch:</b> Change Color & Expand</p>
        <p>Current Mode: <span id="mode-display" class="highlight">Waiting...</span></p>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>

<script>
    /** * CONFIGURATION 
     */
    const PARTICLE_COUNT = 3000;
    const PARTICLE_SIZE = 0.15;
    const LERP_SPEED = 0.08; // How fast particles fly to new shape

    /**
     * THREE.JS SETUP
     */
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 20;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Particle System Variables
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);

    // Initialize random positions
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 50;
        targetPositions[i] = positions[i];
        colors[i] = 1; // White initially
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Shader Material for glowing particles
    const textureLoader = new THREE.TextureLoader();
    // Using a data URI for a simple glow texture to avoid external asset loading issues
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const context = canvas.getContext('2d');
    const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
    gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    context.fillStyle = gradient;
    context.fillRect(0, 0, 32, 32);
    const particleTexture = new THREE.CanvasTexture(canvas);

    const particlesMaterial = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        map: particleTexture,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true
    });

    const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particleSystem);

    /**
     * SHAPE GENERATORS
     * Math formulas to set targetPositions
     */
    
    // 1. Heart Shape
    function setHeartShape(scale = 1) {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const t = Math.random() * Math.PI * 2;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            const z = (Math.random() - 0.5) * 4; // Thickness
            
            targetPositions[i * 3] = x * 0.3 * scale;
            targetPositions[i * 3 + 1] = y * 0.3 * scale;
            targetPositions[i * 3 + 2] = z * scale;
        }
    }

    // 2. Flower Shape
    function setFlowerShape(scale = 1) {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const theta = Math.random() * Math.PI * 2; // Angle around center
            const phi = Math.random() * Math.PI; // Vertical angle
            
            // Flower petal math (polar coordinates)
            const r = 4 + 2 * Math.sin(5 * theta); 
            
            targetPositions[i * 3] = r * Math.cos(theta) * scale;
            targetPositions[i * 3 + 1] = r * Math.sin(theta) * scale;
            targetPositions[i * 3 + 2] = (Math.random() - 0.5) * 2 * scale;
        }
    }

    // 3. Saturn Shape
    function setSaturnShape(scale = 1) {
        const ringCount = Math.floor(PARTICLE_COUNT * 0.6);
        const sphereCount = PARTICLE_COUNT - ringCount;

        // Sphere
        for (let i = 0; i < sphereCount; i++) {
            const r = 3 * Math.cbrt(Math.random()); // Even volume distribution
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            targetPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta) * scale;
            targetPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta) * scale;
            targetPositions[i * 3 + 2] = r * Math.cos(phi) * scale;
        }

        // Ring
        for (let i = sphereCount; i < PARTICLE_COUNT; i++) {
            const theta = Math.random() * Math.PI * 2;
            const r = 5 + Math.random() * 2; // Radius 5 to 7
            
            targetPositions[i * 3] = r * Math.cos(theta) * scale;
            targetPositions[i * 3 + 1] = (Math.random() - 0.5) * 0.2 * scale; // Flat Y
            targetPositions[i * 3 + 2] = r * Math.sin(theta) * scale;
            
            // Tilt the ring
            const x = targetPositions[i * 3];
            const y = targetPositions[i * 3 + 1];
            // Rotate around X axis slightly
            const angle = 0.4;
            targetPositions[i * 3 + 1] = y * Math.cos(angle) - targetPositions[i * 3 + 2] * Math.sin(angle);
            targetPositions[i * 3 + 2] = y * Math.sin(angle) + targetPositions
